第2章 函数

2.1基本概念
2.1.1函数定义
	func funcName(param-list)(result-list){
		function-body
	}
	例如
	func A(){                  //无返回值，默认返回0
		//do something
		...
	}
	func A() int{
		//do something
		...
		return 1
	}
	
	func add(a, b int) int {   //多个相同类型的参数简写
		return a+b
	}
	
	//支持有名的返回值，相当于局部变量，初始化成零值，return可不带参数名
	func add(a, b int) (sum int){
		sum = a+b
		return
		
		//sum := a+b    //此时，相当于新声明一个sum变量命名返回，变量sum覆盖
		//return sum    //最后需要显式地调用return sum
	}
	
	不支持默认参数
	不支持重载
	不支持嵌套，但支持嵌套匿名函数，例如
		func add(a, b int) (sum int){
			anonymous := func(x, y int) int {  //匿名函数，临时函数
				return x+y
			}
			return anonymous(a, b)
		}

2.1.2多值返回
	func swap(a, b int) (int, int){
		return b, a
	}
	如果多值返回有错误类型，一般将错误类型作为最后一个返回值

2.1.3实参到形参的传递
	永远值拷贝
	
	package main
	
	import (
		"fmt"
	)
	
	func chvalue(a int) int {
		a = a+1
		return a
	}
	
	func chpointer(p *int) int {
		*a = *a+1
		return
	}
	
	func main(){
		a := 10
		chvalue(a)     //值传递，产生副本
		fmt.Println(a) //值未更改
		
		chpointer(&a)  //传指针，产生指针的副本，指向相同的地址
		fmt.Println(a) //值发生改变
	}

2.1.4不定参数
	param ...type
	相当于切片，类型必须相同，必须是函数的最后一个参数
	 func sun(arr ...int) (sum int) {
		for _, v := range arr {
			sum += v
		}
		return
	 }
	 
	 //切片可以作为参数传递给不定参数，切片名后加...
	 func main(){
		slice := []int {1, 2, 3, 4}
		array := [...]int{1, 2, 3, 4}
		
		//数组不可以作为实参传递给不定参数的函数
		
		sum(slice...)
		
	 }
	 
	 //形参作为不定参数的函数和形参为切片的函数类型不同
	 func suma(arr ...int) (sum int){
		for v:=range arr{
			sum+=v
		}
		return
	 }
	 func sumb(arr []int) (sum int){
		for v:=range arr{
			sum+=v
		}
		return
	 }
	 
	 //suma和sumb的类型并不一样
	 fmt.Printf("%T\n", suma)   // func(...int) int
	 fmt.Printf("%T\n", sumb)   // func([]int) int

2.2函数签名和匿名函数

2.2.1函数签名
	函数类型又叫函数签名，就是函数定义首行去掉函数名、参数名和{
		fmt.Printf("%T\n", funcName)
	例子：   
		package main

		import "fmt"

		func add(a, b int) int{
			return a+b
		}

		func main(){
			fmt.Printf("%T\n", add)  //func(int, int) int
		}
	
	//两个函数类型相同的条件：拥有相同的形参列表和返回值列表，形参名可以不同
	//下面两个函数签名相同
		func add(a,b int) int { return a+b}
		func sub(x int, y int) (c int) {c=x-y;return c}
	
	
	//type自定义函数类型
		package main

		import "fmt"

		func add(a, b int) int{
			return a+b
		}

		func sub(a, b int) int{
			return a-b
		}

		type Op func(int, int)int  //定义一个函数类型

		func do(f Op, a, b int) int{  //定义一个函数，第一个参数是函数类型Op
			return f(a, b)            //函数类型变量可以直接用来进行函数调用
		}

		func main(){
			a := do(add, 1, 2)        //函数名可以当做相同类型形参，不需要强制类型转换
			fmt.Println(a)     //3
			s := do(sub, 1, 2)
			fmt.Println(s)     //-1
		}
	
	实际函数类型变量和函数名都可以当做指针变量，指向函数代码起始位置，是一种引用类型，未初始化默认为nil
	
	函数为Go语言“第一公民”，有名函数的函数名可作为常量，可直接用函数名调用函数，也可以直接
	赋值给函数类型变量
		package main

		func sum(a, b int) int {
			return a+b
		}
		func main(){
			sum(3, 4)   //直接调用
			f:=sum      //有名函数直接赋值给变量
			f(1,2)
		}

2.2.2匿名函数
	函数字面量
	例子：
	
	package main

	import "fmt"
	//匿名函数被直接赋值函数变量
	var sum = func(a, b int) int {
		return a+b
	}

	//匿名函数作为参数
	func doinput(f func(int, int)int, a, b int) int{
		return f(a, b)
	}

	//匿名函数作为返回值
	func wrap(op string) func(int, int) int{
		switch op{
			case "add":
				return func(a, b int) int{
					return a+b
				}
			case "sub":
				return func(a, b int) int{
					return a-b
				}
			default:
				return nil
		}
	}

	func main(){
		//匿名函数直接被调用
		defer func(){
			if err:= recover(); err!=nil{
				fmt.Println(err)
			}
		}()
		
		sum(1, 2)
		
		//匿名函数作为实参
		doinput(func(x,y int) int{
			return x+y
		}, 1, 2)
		
		opFunc := wrap("add")
		re := opFunc(2, 3)
		
		fmt.Printf("%d\n", re)
	}
	
2.3 defer
	可以注册多个延迟调用，先进后出的顺序在函数返回前被执行
	常用于保证一些资源最终一定能够得到回收和释放
	defer后面必须是函数或方法的调用
	例1：
		package main

		import "fmt"

		func main(){
			//先进后出
			defer func(){
				fmt.Println("first")
			}()
			defer func(){
				fmt.Println("second")
			}()
			fmt.Println("function body")
		}
		//结果如下
		function body
		second
		first
	例2：
		//实参在注册时通过值拷贝传递进去
		func f() int{
			a:=0
			defer func(i int){
				fmt.Println("defer i=", i)
			}(a)    //此时a=0，i接收也是0，值拷贝，后面a++不影响i的值
			
			a++
			return a
		}
		
		//defer打印结果
		defer i=0
	
	例3：
		//defer语句必须先注册后才能执行， 如果defer位于return之后，则defer因为没有注册，不会执行
		package main

		import "fmt"

		func main(){
			//先进后出
			defer func(){
				fmt.Println("first")
			}()
			a :=0
			fmt.Println(a)
			return 
			defer func(){     //return后没能注册上，因此不会被执行
				fmt.Println("second")
			}()
		}
		结果：
		0
		first
	
	例4：
		//主动调用os.Exit(int)退出进程时， defer将不再被执行（即使defer已经提前注册）
		package main

		import (
			"fmt"
			"os"
		)

		func main(){
			//先进后出
			defer func(){
				fmt.Println("defer")
			}()
			fmt.Println("func body")
			
			os.Exit(1)
		}
		//结果
		func body


		Exited with error status 1
		
	例5：
		//在一定程度上避免资源泄漏
		func CopyFile(dst, src string) (w int64, err error){
			src, err := os.Open(src)
			if err != nil {
				return
			}
			defer src.Close()
			
			dst, err := os.Create(dst)
			if err!=nil {
				return
			}
			defer dst.Close()
			
			w, err = io.Copy(dst, src)
			
			return
		}
		
	
	其他说明：
		defer语句位置不当，有可能引发panic，一般defer语句放在错误检查语句之后
		defer副作用，会推迟资源的释放，defer尽量不要放到循环语句里

2.4闭包
2.4.1概念
	闭包 = 函数 + 引用环境
	一般通过匿名函数中引用外部函数的局部变量或全局变量构成
	
	package main

	import (
		"fmt"
	)

	func fa(a int) func(i int) int{   
		return func(i int) int{
			fmt.Println(&a, a)
			a = a+i
			return a
		}
	}
	
	//上面个人理解的是 函数fa会返回闭包，当前闭包是一个匿名函数+加上一个局部变量a

	func main(){
		//函数fa本次通过传入参数1后返回闭包，被f引用
		f:=fa(1)          //f引用的外部的闭包环境包括本次函数调用的形参a的值1
		g:=fa(1)          //g引用的外部的闭包环境包括本次函数调用的形参a的值1
		
		//f和g不是一个，闭包环境中a的值并不是同一个，是两个函数调用产生的两个副本
		
		fmt.Println(f(1))
		//多次调用f引用的是同一个副本a
		fmt.Println(f(1))
		
		//g中a的值仍然是1
		fmt.Println(g(1))
		fmt.Println(g(1))
		
	}

	//运行结果
	0xc000016060 1
	2
	0xc000016060 2
	3
	0xc000016068 1
	2
	0xc000016068 2
	3
	
	//f和g引用的是不同的a
	//如果一个函数调用返回的闭包引用，则每次调用都会影响全局变量
	
	
	//尽量不要用闭包引用全局变量，引用的例子如下：
	package main

	import "fmt"

	var (
		a = 0    //全局变量a
	)

	func fa() func(i int) int{
		return func(i int) int {
			fmt.Println(&a, a)
			a = a+i
			return a
		}
	}

	func main(){
		f:=fa()
		g:=fa()
		//此时f、g引用的闭包环境的a是一个值
		fmt.Println(f(1))
		fmt.Println(g(1))
		fmt.Println(g(1))
		fmt.Println(g(1))
	}
	
	//结果
	0x57aa58 0
	1
	0x57aa58 1
	2
	0x57aa58 2
	3
	0x57aa58 3
	4


	//同一个函数返回的多个闭包共享该函数的局部变量。例如
	package main

	import "fmt"



	func fa(base int) (func(int) int, func(int) int){
		fmt.Println(&base, base)
		add := func(i int) int{
			base += i
			fmt.Println(&base, base)
			return base
		}

		sub := func(i int) int{
			base -= i
			fmt.Println(&base, base)
			return base
		}
		return add, sub
	}

	func main(){
		f, g := fa(0)
		s, k := fa(0)
		
		fmt.Println(f(1), g(2))
		fmt.Println(s(1), k(2))
	}
	//结果
	0xc000016060 0
	0xc000016068 0
	0xc000016060 1
	0xc000016060 -1
	1 -1
	0xc000016068 1
	0xc000016068 -1
	1 -1
	
2.4.2闭包的价值
	闭包最初的目的是减少全局变量，函数调用隐式传递共享变量
	缺点，不够直接，不清晰
	除非有用的地方，一般不使用闭包
	
	对象是附有行为的数据，而闭包是附有数据的行为
	类在定义时已经显式集中定义行为，但是闭包中数据没有显式集中声明的地方
	
	闭包不是不可缺少
