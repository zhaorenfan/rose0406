1.3Go词法单元
1.3.1~3 token
  token是构成源程序的基本不可再分割的单元
  token分类：
    -关键字 只有25个 func package import等等
    -类型标识符 int string bool等

    -内置函数 make new 等
    -常量标识符 true false iota nil

    -操作符 + - & , : ; . ... <-等
    -纯粹的分隔符4个 空格 制表符 回车 换行

    -字面常量，简称字面量 一般用裸字符序列表示不同类型的值，
      Go中常用在两个地方（1）常量和变量的初始化（2）表达式或者作为函数调用实参
      Go不支持用户自定义字面量
      例子：整形字面量 42 0600 0xBadFace 1721213545487
            浮点型字面量 0. 72.40 072.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12544E+5
            复数字面量
            字符型字面量 'a' '本' '\t' '\377' '\x07'
            字符串字面量 "\n"   "\""相当于 "  "hello, world！\n" "中国人"

1.4变量和常量
    变量：一个名称，来绑定一块内存地址，指向的内存可以被修改
    常量：指向的内存不可以被修改
1.4.1变量
    1.显示声明
        var varName dataType [ = value ]
        例如：var a int = 1
    2.短类型声明(常用)
        varName := value
        例如：b := "hello"

1.4.2常量
    可以是布尔型、字符串型和数值型

    //类似枚举的iota
    const (
        c0 = iota //c0 == 0
        c1
        c2
    )

1.5基本数据类型
1.5.1 布尔类型
    bool 只有两个值 true false
    例子 var ok bool   //默认为false
        ok = true
        或者 
        ok := true
    
    for ;true; {  //等价于c语言的while(1)

    }
1.5.2整型
    var a int = 1
    var b int32 = 2
    b = a //error，因为是两个类型，需要强制类型转换

    var a int = (1+2)*3
    var b int = 1000>>2 //位运算符

1.5.3浮点型
    float32和float64
    var b := 10.0 //默认被推断成float64
    浮点数不应该使用 == 或!=比较，高精度需求应使用math标注库
1.5.4复数
省略

1.5.5字符串
        var a = "hello, world"
    (1)字符串是常量，可通过类似数组索引方式访问其字节单元，但不能修改某个字节值
        var a = "hello, world"
        b := a[0]
        a[1] = 'a' //error

    (2)字符串转换成切面[]byte(s)要慎用，尤其数据量大时，每次转换都要复制内容
        a:="hello, world"
        b:=[]byte(a)

    (3)结尾不包含NULL字符，和C/C++不一样
    (4)底层实现 二元数据结构 略
    (5)基于字符串创建的切片，仍是字符串string，并非slice
        a:="hello, world"
        b := a[0:4]
        c := a[1:]
        c := a[:4]
    (6)字符串转换成切片
        a :="hello, world"
        b :=[]byte(a)    //字节数组，byte是uint的别名，
        c :=[]rune(a)    //Unicode编码的rune数组，rune是Go内部int32类型的别名，占4个字节
    
    (7)字符串运算
        a :="hello"
        b :="world"

        c := a + b  //字符串拼接
        len(c)      //内置函数，返回字符串长度

        d := "hello, 世界"

        for i:=0; i<len(d);i++{ //遍历字节数组
            fmt.Println(d[i])
        }

        for i,v :=range d{     //遍历rune数组
            fmt.Println(i, v)
        }

1.6复合数据类型
指针、数组、切片、字典(map)、通道、结构体和接口
字面量格式如下：
* pointerType    //指针 *后面跟其指向的类型
[n] elementType  //数组 n为长度
[] elementType   //切片
map [keyType] valueType    //map
chan valueType             //通道
struct {                   //结构体
    feildName feildType
    feildName feildType
    ...
}
interface {                //接口
    method1(inputParams) (returnParams)
    method2(inputParams) (returnParams)
}

1.6.1指针（指向内存的地址）
    指针声明为*T,多级指针**T, 变量名前&可以获取变量的地址
    (1)赋值语句，*T在等号左侧表明指针声明，*T在等号右侧表明取地址的值
        var a = 11
        p := &a     // *p和a的值都是11
    (2)结构体指针
        type User struct {
            name string
            age int
        }
        andes := User{
            name: "andes",
            age: 18,
        }
        p := &andes    //结构体指针
        fmt.Println(p.name)   //访问元素仍然用 . 访问成员变量 （Go中没有->操作符）
    (3)指针不能运算
        p++  //不允许， 报non-numeric type *int错误
    (4)函数允许返回局部变量的地址
        func sum(a, b int) *int{
            sum := a+b
            return &sum    //允许，sum会分配在heap上
        }

1.6.2数组
    var arr [2]int  //声明有两个整型的数组，默认都是0
    array := [...]float64(7.0, 8.5, 9.1)   //初始化列表

    数组初始化
        a := [3]int{1, 2, 3}
        a := [...]int{1, 2, 3}  //长度由列表数量确定
        a := [3]int{1:1, 2:3}  //索引初始化，没有初始化的使用默认值
        a := [...]int{1:1, 2:3} //长度由最后一个索引确定
    
    数组特点：
        (1)长度初始化后就直接固定，不可再多加元素
        (2)数组是值类型， 赋值和函数传参数都是 值拷贝
        (3)长度是类型的一部分 [10]int 和 [20]int表示不同的类型
        (4)可以根据数组创建切片
    
    数组相关操作
        (1)元素访问
            a := [...]int{1, 2, 3}
            b :=a[0]
            for i,v := range a{

            }
        (2)数组长度
            a := [...]int{1, 2, 3}
            alength := len(a)

            for i:=0;i<alength;i++{

            }

1.6.3切片
    slice可变长度的数组，是一种引用类型，维护三个元素--指向底层数组的指针、切片数量和底层数组的容量
    (1)切片的创建
    ·由数组创建
        array[b:e]     第一个元素是array[b]，最后一个元素是array[e-1]
    例子：
        var array := [...]int{0, 1, 2, 3, 4, 5, 6}
        s1 := array[0:4]
        s2 := array[:4]
        s3 := array[2:]
        fmt.Printf("%v\n", s1)   // [0 1 2 3]
        fmt.Printf("%v\n", s2)   // [0 1 2 3]
        fmt.Printf("%v\n", s3)   // [2 3 4 5 6]
    
    ·通过内置函数make创建切片
        默认为类型的零值,容量cap要大于长度len
        //len=10, cap=10
        a := make([]int 10)

        //len=10, cap=15
        b := make([]int 10, 15)
        fmt.Printf("%v\n", a)   //[0 0 0 0 0 0 0 0 0 0]
        fmt.Printf("%v\n", b)   //[0 0 0 0 0 0 0 0 0 0]

        *注意：直接声明切片类型变量是没意义的
        var a []int
        fmt.Printf("%v\n", a)   //结果为 []
    
    (2)切片操作
        ·内置函数len()返回切片长度
        ·内置函数cap()返回切片底层数组容量
        ·内置函数append()对切片追加元素
        ·内置函数copy()用于复制一个切片
    示例如下：
        a := [...]int{0, 1, 2, 3, 4, 5, 6}
        b := make([]int, 2, 4)    // [0 0]
        c := a[0:3]

        fmt.Println(len(b))      //2
        fmt.Println(cap(b))      //4

        b = append(b, 1)
        fmt.Println(b)           //[0 0 1]
        fmt.Println(len(b))      //3
        fmt.Println(cap(b))      //4

        b = append(b, c...)
        fmt.Println(b)           //[0 0 1 0 1 2]
        fmt.Println(len(b))      //6
        fmt.Println(cap(b))      //8    底层数组自动扩展

        d := make([]int, 2, 2)
        copy(d, c)                //copy只会复制d和c中长度最小的
        fmt.Println(d)            //[0 1]
        fmt.Println(len(d))       //    2
        fmt.Println(cap(d))       //    2
    
    (3)字符串和切片的相互转换。例如
        str := "hello, 世界！"
        a := []byte(str)
        b := []rune(str)

1.6.4 map
	字典
	map[K] T
	键-值对
	key-value
	(1)map创建
		·使用字面量创建
			ma := map[string]int{"a": 1, "b": 2}
			fmt.Println(ma["a"])
			fmt.Println(ma["b"])
		·使用内置的make函数创建
			语法如下：
			make(map[K]T)        //map的容量使用默认
			make(map[K]T, len)   //map的容量使用给定值
			
			mp1 := make(map[int]string)     //map的容量使用默认
			mp2 := make(map[int]string, 10) //map的容量是10
			map1[1] = "tom"     //赋值
			map2[1] = "pony"
			fmt.Println(mp1[1])   //tom
			fmt.Println(mp2[1])   //pony
	(2) map支持的操作
		·单个键值访问格式如下：
			mapName[key] = value  //更新
			var v = mapName[key]  //访问
		·使用range遍历map，但是不保证顺序
		·删除map某个键值,使用内置函数delete，格式为：
			delete(mapName, key)
		·内置函数len()返回map键值对的数量。
			mp := make(map[int]string)
			mp[1] = "tom"
			mp[1] = "pony"
			mp[2] = "jaky"
			mp[3] = "andes"
			
			delete(mp, 3)
			
			fmt.Println(mp[1])
			fmt.Println(len(mp))
			
			for k, v := range mp{
				fmt.Println("key=", k, "value=", v)
			}
	注意：
		·Go内置的map不是并发安全的，并发安全需要用标准包sync中的map
		·不要直接修改map中value内某个元素的值（value为结构体，不能通过map直接修改成员变量）
		 需要整体赋值
		 例如：
		 type User struct {  
			name string
			age int
		 }
		 ma := make(map[int]User)
		 andes := User{
			name: "andes",
			age: 18,
		 }
		 
		 ma[1] = andes
		 //ma[1].age = 19   //ERROR， 不能通过map引用直接修改 
		 andes.age = 19     //可以这么修改
		 ma[1] = amdes      //整体替换回来
		 fmt.Printf("%v\n", ma)
	
1.6.5 struct
	结构体
	第一：struct结构中的类型可以任意
	第二：struct的存储空间连续，字段按照声明顺序存放（字段间有对其要求）
	（1）struct字面量 (不常用)
		struct {
			FieldName FeildType
			FieldName FeildType
			FieldName FeildType
		}
	（2）自定义struct类型 （常用）
		type TypeName struct {     //type为自定义类型的关键字，除了struct还用于其他子定义类型创建
			FieldName FeildType
			FieldName FeildType
			FieldName FeildType
		}
	（3）struct类型变量的初始化
		type Person struct {
			Name string
			Age int
		}
		type Student struct {
			*Person
			Age int
		}
		//按照类型声明顺序，逐个赋值
		//不推荐这种初始化方式，一旦struct增加字段，整个初始化语句报错，修改不方便
		a := Person("Tom", 21)
		
		//推荐下面初始化方法,没有指定字段默认为类型零值
		a := &Persion{              //结构体指针，指向结构体的地址
			Name: "TangTang",
			Age: 18,
		}
		
		s := Student {
			Person: p,
			Number: 110,
		}

1.7控制结构
	程序执行本质上就是两种模式：顺序和跳转
	
1.7.1 if语句
	·if后面不需要小括号
	·{必须放行尾，和if或if else放在一行
	·if后面可以带一个简单的初始化语句，以分号分割，该变量作用域是整个if语句块，包括分支
	·没有（a>b?a:b）语句
	·分支遇到return直接返回，遇到break跳到下方的if语句块
	示例：
		if x<=y {
			return y
		} else {
			return x
		}
		
		
		if x:=f(); x<y {  //初始化语句中声明变量x
			return x
		} else if x>z {   //x在分支一样可以被访问
			return z
		} else {
			return y
		}
		
		err, file := os.Open("xxx")
		if err!= nil{
			return nil, err
		}
		defer file.Close()
		//do something

1.7.2 switch语句
	·switch后面也可以带一个简单的初始化语句
	·switch后面的表达式可选，没有则case子句为布尔表达式
	·表达式不像C语言必须为整数，可以任意比较运算的
	·fallthrough语句强制执行下一条case语句
	·default可以放到任意位置
	·switch和（.type）结合可以进行类型查询，再说
	
	switch i:= "y"; i {
		case "y", "Y":
			fmt.Println("yes")
			fallthrough
		case "n", "N":
			fmt.Println("no")
	}
	
	score := 85
	grade := ' '
	switch {
		case score >= 90:
			grade = 'A'
		case score >= 80:
			grade = 'B'
		case score >= 70:
			grade = 'C'
		case score >= 60:
			grade = 'D'
		default:
			grade = 'F'
	}
	
	fmt.Println(grade)

1.7.3 for语句
	应用的三种场景
	类似C的for循环
		for init; condition; post {}
	类似C的while循环
		for condition {}
	类似C的while(1)死循环
		for {}
	此外，对于数组、切片、字符串、map和通道的访问
	
		//访问map
		for key, value := range map { }
		for key := range map { }
		
		//访问数组
		for index, value := range arry{}
		for index := range arry{}
		for _, value := range arry{}
		
		//访问切片，和数组一样
		for index, value := range slice{}
		for index := range slice{}
		for _, value := range slice{}
		
		//访问通道
		for value := range channel{}

1.7.4标签和跳转
	标签Label用于标识一个语句的位置，用于goto、break、continue语句的跳转
	标签语法如下：
		Label： Statement
	(1)goto语句用于函数内部跳转、需要配合标签一起使用
	
	(2)break 用于函数内跳出for、switch、select语句
	//break可以单独使用跳出最近循环或者和标签配合使用跳出标签所在循环
	L1:
		for i:=0;  ;i++{      //循环1
			for j:=0; ; j++{    //循环2
				if i>=5 {
					//跳出L1所在循环 ，即循环1
					break L1
				}
				if j>10 {
					//默认仅跳出离break最近的内层循环 ，即循环2
					break
				}
			}
		}
	
	(3)continue，用于跳出for循环的本次迭代
	L1:
		for i:=0;  ;i++{      //循环1
			for j:=0; ; j++{    //循环2
				if i>=5 {
					//跳到标签L1所在for循环（循环1） i++处继续执行
					continue L1
				}
				if j>10 {
					//默认仅跳到离continue最近的内层循环（循环2） j++处继续执行
					continue
				}
			}
		}
		
	(4)return和函数调用
		return也能引发控制流程的跳转，用于函数和方法的退出。函数和方法的调用也能引发程序控制流的跳转。

第一章完笔记完结
用时1天

