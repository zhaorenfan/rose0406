3.3.3方法表达式

3.3.4方法集
package main
import "fmt"

type Int int

func(a Int) Max(b Int) Int{
    if a>=b{
        return a
    }else{
        return b
    }
}

func(i *Int) Set(a Int){
    *i = a
}

func (i *Int) Print(){
    fmt.Printf("value=%d\n", i)
}

func main(){
    var a Int = 10
    var b Int = 20

    c:=a.Max(b)
    c.Print()
    (&c).Print()

    (&a).Set(30)
    a.Print()
}

3.3.5值调用和表达式调用的方法值

3.4组合和方法值
3.4.1组合
3.4.2组合的方法集
规则如下：
（1）若类型S包含匿名字段T，则S的方法集包含T的方法集
（2）若类型S包含匿名字段*T，则S的方法集包含T和*T的方法集
（3）不管类型S中嵌入的匿名字段是T还是*T，*T方法集总是包含T和*T的方法集

3.5函数类型
匿名函数不能独立存在，常作为函数参数、返回值，或者赋值给某个变量
匿名函数可以直接显示初始化
匿名函数的类型也可以是函数字面量类型func (int, int) int
func (a, b int) int{
	return a+b
}

第4章 接口
变量和实例
接口只有声明，没有实现。定义接口和声明接口是一个意思
空接口 interface{}
4.1接口声明
//接口字面量类型声明
interface{
	MethodSignature1
	MethodSignature2
}

//接口命名类型使用type关键字(常用)
type InterfaceName interface{
	MethodSignature1
	MethodSignature2
}

type Reader interface{
	Read(p []byte) (n int, err error)
}

type Writer interface{
	Write(p []byte) (n int, err error)
}

//如下三种是等价的，最终都展开第三种
type ReaderWriter interface{
	Reader
	Writer
}

type ReaderWriter interface{
	Reader
	Writer(p []byte) (n int, err error)
}

type ReaderWriter interface{
	Reader(p []byte) (n int, err error)
	Writer(p []byte) (n int, err error)
}

方法声明=方法名+方法签名
MethodName (InputTypeList)OutputTypeList

声明新接口类型的特点
（1）接口一般以"er"结尾
（2）接口的定义的内部方法声明不需要func引导
（3）在接口定义中，只有方法声明没有方法实现

4.1.2接口初始化
默认值为nil
var i io.Reader
fmt.Print("%T\n", i) //nil

接口变量赋值给接口变量
file,_ :=os.OpenFile("note.txt", os.O_RDWR|os.O_CREATE, 0755)

var rw io.ReaderWriter = file
var w io.Writer = rw

4.1.3接口方法调用
4.1.4接口的动态类型和静态类型

4.2接口运算
4.2.1类型断言
i.(TypeName)

o:=i.(TypeName)














